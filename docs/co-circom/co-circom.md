# coCircom

coCircom enables us perform [circom](../resources/circom)'s witness extension and proof generation within MPC. circom and coCircom and their artifacts may be used interchangeably, e.g. a proof generated by coCircom verfies using circom and vice-versa. coCircom also relies on artifacts generated by circom, e.g. the R1CS file, the zkey, and the vkey.

The prerequisite for this documentation are the docs of [circom.io](https://docs.circom.io/getting-started/computing-the-witness/), where we will use the same terminology. We will leave out details that are given at [circom.io](https://docs.circom.io/getting-started/computing-the-witness/) and focus on the differences for using coCircom. 

To get started with the coCircom workflow, we require some circuit alongside an input. Based on these files we can create a proof according the workflow depicted in the figure below that uses the three-party protocol REP3. Details such as r1cs file generation, zkey & vkey generation, and powers of tau are omitted in this drawing, where where we refer to the circom docs for [extending the witness](https://docs.circom.io/getting-started/computing-the-witness/) and [generating a proof](https://docs.circom.io/getting-started/proving-circuits/). 

<img src={require("./figures/co-circom-workflow.png").default} alt="overview drawing" width="90%"/>

You might have noticed that you can either generate the witness using snarkjs or coCircom. Generating the witness using coCircom provides the amazing privacy benefits of MPC, while being very computationally expensive due to the fact that witness extension uses general computations inside TACEO's MPC VM. Proof generation using coCircom on the other hand is very efficient where proving time even is slightly faster than snarkjs' proving time. This is due to the fact that the computationally expensive operations required to compute a zk-proof are very efficient in MPC as they are linear operations (FFTs, MSMs).

All nodes produce the same `proof.json` and `public.json` file. Only one of the nodes needs to deliver these artifacts (depicted by dotted lines in the drawing above).

The rest of this section is split into two main topics, where the first one expands on using [coCircom's CLI](./cli/cli.md) and the second one covers the [Rust library](./lib/lib.md). There is also a [coCircom Quick Start](../getting-started/quick-start-co-circom.md) guide for getting your hands dirty straight away.