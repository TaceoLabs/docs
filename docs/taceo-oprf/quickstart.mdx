# Quickstart

Letâ€™s start by installing our client binary for TACEO:OPRF! You can download a ready to use client from the GitHub releases [https://github.com/TaceoLabs/oprf-testnet/releases](https://github.com/TaceoLabs/oprf-testnet/releases). If you are on macOS you might need to allow executing of the binary with:

```bash
xattr -dr com.apple.quarantine taceo-oprf-testnet-client
```

Or you can clone the repository,

```bash
git clone https://github.com/TaceoLabs/oprf-testnet.git
```

Install the required dependencies:

- Rust ([https://rust-lang.org/learn/get-started/](https://rust-lang.org/learn/get-started/))
- On Ubuntu `build-essential` name may vary on other platforms

And build it from source using the following command:

```bash
cargo install --path oprf-testnet-client --locked
```

You should now have a client binary called `taceo-oprf-testnet-client` that you can run to interact with TACEO:OPRF.

This specific instance of TACEO:OPRF that we are spinning up has two authorization modules and two different OPRF keys, one for each module. Of course it is also possible to have unlimited amount of OPRF keys for one authorization module, but in this example we stick with one per module.

**Simple Authorization Module**

The first authorization module (https://github.com/TaceoLabs/oprf-testnet/blob/c143033ee820f46eef8714d472d6c0e9c1e5eab0/oprf-testnet-authentication/src/lib.rs#L222) is pretty simple, it just verifies that a given API key is valid and then runs the OPRF flow for the provided action.

[https://github.com/TaceoLabs/oprf-testnet/blob/c143033ee820f46eef8714d472d6c0e9c1e5eab0/oprf-testnet-authentication/src/lib.rs#L192](https://github.com/TaceoLabs/oprf-testnet/blob/c143033ee820f46eef8714d472d6c0e9c1e5eab0/oprf-testnet-authentication/src/lib.rs#L192)

To try it out, simply run the following command:

```bash
taceo-oprf-testnet-client \
	--api-key taceo_3ZfE55WkcNWRweh5rcfpUNpi \
	basic \
	--input 42
```

If everything worked correctly, you should see the final OPRF output in your terminal. The output is deterministic and based on the provided input, so if you run the same command again, you will get the same OPRF output.

Since the OPRF secret is used to derive the output, no one can guess the output without querying the OPRF nodes with the same input, and this is guaranteed by the cryptographic properties of the used OPRF.

**Wallet Authorization Module**

The second authorization module (https://github.com/TaceoLabs/oprf-testnet/blob/c143033ee820f46eef8714d472d6c0e9c1e5eab0/oprf-testnet-authentication/src/lib.rs#L192) verifies that the user controls a given Etherum wallet (by verifying it signed a specific message) and generates a nullifier associated with this wallet which only the owner of the wallet private key can generate. Per default, the client binary generates a fresh Ethereum wallet for this process and prints the private key and public address, so you do not need to trust a random binary you just downloaded with your real private key.

For this module you will need [Barretenberg](https://barretenberg.aztec.network/docs/getting_started) `v3.0.0-nightly.20260102`. To get `bb` you can follow the instructions in their docs, or just install it with `bbup` via the following commands:

```bash
curl -L https://raw.githubusercontent.com/AztecProtocol/aztec-packages/refs/heads/next/barretenberg/bbup/install | bash
```

Make sure `bbup` is in you `PATH` by sourcing the appropriate file or restarting your shell

```bash
bbup -nv 1.0.0-beta.18
```

We will use `bb` to compute and verify two ZK proofs.

The first (https://github.com/TaceoLabs/oprf-testnet/blob/main/noir/blinded_query_proof/src/main.nr) for proving ownership of the wallet, which the authorization module verifies together with the API.

```rust
fn main(
    hashed_message: pub [u8; 32],
    pub_key_x: [u8; 32],
    pub_key_y: [u8; 32],
    signature: [u8; 64],
    beta: Field,
) -> pub BabyJubJubPoint {
    // The function ecrecover takes in a hashed message, a public key (x and y coordinates) and a signature, verifies the signature and returns the recovered ETH address, which is used as the input to the OPRF protocol.
    let address = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);

    // Generate the query proof point.
    blinded_query(beta, address)
}
```

And the second (https://github.com/TaceoLabs/oprf-testnet/blob/main/noir/verified_oprf_proof/src/main.nr) for proving that the generated nullifier is associated with the wallet.

```rust
fn main(
    // These are the inputs needed for the first part of the OPRF protocol, the query proof.
    hashed_message: pub [u8; 32],
    pub_key_x: [u8; 32],
    pub_key_y: [u8; 32],
    signature: [u8; 64],
    beta: Field,
    // These are the inputs needed for the second part of the OPRF protocol, the verified OPRF output.
    oprf_pk: pub BabyJubJubPoint,
    dlog_e: Field,
    dlog_s: Field,
    oprf_response_blinded: BabyJubJubPoint,
    oprf_response: BabyJubJubPoint,
) -> pub Field {
    // Similar to the blinded query proof, we first recover the user input (address) from the signature.
    let address = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);
    // Inside the verified_oprf function, we recompute the blinded query proof to check that the original query was computed correctly, verify the dlog equality proof, verify the unblinding was done correctly, and then generate the final verified OPRF output.
    verified_oprf(
        beta,
        oprf_pk,
        dlog_e,
        dlog_s,
        oprf_response_blinded,
        oprf_response,
        address,
        DS_DLOG,
        DS_N,
    )
}
```

To try it out, simply run the following command:

```bash
taceo-oprf-testnet-client \
	--api-key taceo_3ZfE55WkcNWRweh5rcfpUNpi \
	wallet-ownership
```

If everything worked correctly, you should see the private key of a randomly generated ETH wallet and the final OPRF output in your terminal. You should also have `proof` and `public_inputs` files the current directory. You can re-use the generated private key and confirm the the generated nullifier is still the same:

```rust
taceo-oprf-testnet-client \
	--api-key taceo_3ZfE55WkcNWRweh5rcfpUNpi \
	wallet-ownership \
	--private-key <PREVIOUSLY_GENERATED_PRIVATE_KEY>
```

To get the verifying key, you go to the repository and download it from there, or you can download it with the following command:

```rust
curl -sSLO https://github.com/TaceoLabs/oprf-testnet/raw/refs/heads/main/oprf-testnet-authentication/verified_oprf_proof.vk
```

You can then verify the proof using the following command:

```bash
bb verify -p proof -i public_inputs -k verified_oprf_proof.vk
```

## Local Setup

If you want to experiment more with TACEO:OPRF, then you can also spin up your own local network. To do that you first need to clone the repository and its submodules.

```bash
git clone --recursive https://github.com/TaceoLabs/oprf-testnet.git
```

You also need a couple more dependencies.

- `docker compose` to start localstack, postgres and oprf-key-gen containers (See [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/))
- `anvil` and `forge` from Foundry (See [https://www.getfoundry.sh/introduction/getting-started](https://www.getfoundry.sh/introduction/getting-started))
- `just` to run command for the local setup (See https://github.com/casey/just)

To start a local setup, we need to do the following steps in order:

1. Start the `anvil`, and the `localstack`, and `postgres` docker containers
2. Deploy the `OprfKeyRegsitry` contract on `anvil`
3. Start the 3 `oprf-key-gen` docker containers for the 3 nodes
4. Start the 3 `oprf-testnet-node` binaries
5. Create the OPRF keys for both OPRF modules

All of which is done for you by running the following command:

```bash
just run-setup
```

Now you can run the the client binary again, but this time point it to you local OPRF nodes with the following command:

```bash
taceo-oprf-testnet-client \
	--nodes http://127.0.0.1:10000,http://127.0.0.1:10001,http://127.0.0.1:10002 \
	--api-key taceo_3ZfE55WkcNWRweh5rcfpUNpi \
	wallet-ownership
```

Feel free to play around, e.g., modifying the authentication modules to add your own logic there or even changing the zero knowledge proof to verify different properties of the input such as allowing only vanity addresses that end in `c0ffee`.

---