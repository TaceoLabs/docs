# TACEO:Proof CoNoir

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

To make it easy to seamlessly integrate **TACEO:Proof** into your applications, we implemented client libraries for different languages.
You can find the client libraries and example clients in the [proof-client](https://github.com/TaceoLabs/proof-client) repository.
There you will find installation instructions and example circuits.

<Tabs>
<TabItem value="javascript" label="JavaScript/TypeScript" default>

The JavaScript clients use WebAssembly generated with [wasm-pack](https://github.com/rustwasm/wasm-pack) and therefore need different packages for different [targets](https://rustwasm.github.io/docs/wasm-pack/commands/build.html#target).
Currently we support `nodejs` and `bundler` with their respective npm packages `@taceo/proof-client-node` and `@taceo/proof-client-bundler`.

- **Installation**: Install the package for your target using your favorite package manager 

  ```bash
  npm install @taceo/proof-client-node
  ```

- **Setup**: Create the API client configuration

  ```ts
  const configParams: ConfigurationParameters = {
    basePath: "https://proof.taceo.network",
  }
  const configuration = new Configuration(configParams)
  const jobInstance = new JobApi(configuration );
  const nodeInstance = new NodeApi(configuration );
  ```

- **Witness Extension + Prove Job**:

  With a full prove job, the input is secret-shared, encrypted, and distributed to the designated nodes for processing.
  The workflow does not require a precomputed extended witness; instead, the witness extension is generated during the job execution, which is then followed by proof generation.
  This approach eliminates the need to upload potentially large witnesses.

  ```ts
  const nodes = await nodeInstance.randomNodeProviders();
  const blueprintId = "54f9ee38-0160-44e2-a1d8-08d1b6771cbf";
  const voucher = null; // only required for Restricted blueprints
  const abi = JSON.parse(fs.readFileSync("abi.json").toString());
  const publicInputs = new Uint32Array([1, 2]); // Replace with actual public input indices
  const input = JSON.parse(fs.readFileSync("Prover.json").toString());
  const jobId = await CoNoir.scheduleFullJob(
    jobInstance,
    nodes,
    blueprintId,
    voucher,
    abi,
    publicInputs,
    input
  );
  ```

- **Multiple Inputs Witness Extension + Prove Job**:

  This job supports multiple inputs from different users without revealing inputs to each other.
  Once all inputs for the job are present, it is sent to designated nodes, which then execute the job.
  Additionally, an optional deadline can be set to limit the amount of time that can pass before all inputs must be present.
  Inputs can be dynamically added to an already created job. The input data is secret-shared, encrypted, and collected until the job gets scheduled.
  This approach enables more flexible workflows and computational processes.

  ```ts
  const nodes = await nodeInstance.randomNodeProviders();
  const blueprintId = "54f9ee38-0160-44e2-a1d8-08d1b6771cbf";
  const voucher = null; // only required for Restricted blueprints
  const deadline = new Date(Date.now() + 3600 * 1000); // 1 hour from now
  const jobId = await CoNoir.scheduleFullMultipleInputsJob(
    jobInstance,
    nodes,
    blueprintId,
    voucher,
    deadline
  );
  // multiple users can now add inputs to this job given the jobId and the selected nodes
  const abi = JSON.parse(fs.readFileSync("abi.json").toString());
  const publicInputs = new Uint32Array([1, 2]); // Replace with actual public input indices
  const input = JSON.parse(fs.readFileSync("Prover.json").toString());
  await CoNoir.addJobInputs(jobInstance, nodes, jobId, abi, publicInputs, input);
  ```

- **Prove Job**:

  A proof job can be scheduled using either the Rep3 or Shamir Secret Sharing scheme.
  The process involves taking a witness, secret-sharing it, encrypting these shares, and distributing them to the designated nodes for execution.

  ```ts
  const nodes = await nodeInstance.randomNodeProviders();
  const blueprintId = "54f9ee38-0160-44e2-a1d8-08d1b6771cbf";
  const mpcProtocol = "Rep3"; // specify the MPC protocol to use (Rep3 or Shamir)
  const voucher = null; // only required for restricted blueprints
  const publicInputs = new Uint32Array([1, 2]); // Replace with actual public input indices
  const witness = new Uint8Array(fs.readFileSync("witness.gz"));
  const jobId = await CoNoir.scheduleProveJob(
    jobInstance,
    nodes,
    blueprintId,
    mpcProtocol,
    voucher,
    publicInputs,
    witness
  );
  ```

- **Fetch the job Results**:

  The results of a job execution can be retrieved via a WebSocket connection.
  Once the results are ready, the server sends a message containing the proof, public inputs, and signatures of the computing nodes.
  If any party encounters an error, an error message is returned instead.
  The received proof and public inputs are serialized `HonkProof<ark_bn254::Fr>` and `Vec<ark_bn254::Fr>` types as defined by [noir-types](https://github.com/TaceoLabs/co-snarks/tree/main/co-noir/noir-types).

  ```ts
  const wsUrl = "wss://proof.taceo.network/api/v1/reports/subs";
  const jobId = "9c2814d7-25d3-4de5-b61f-0a6e3bacbe99";
  const { proof, public_inputs, signatures } = await CoNoir.fetchJobResult(wsUrl, jobId);
  fs.writeFileSync("proof", proof_bytes);
  fs.writeFileSync("public_inputs", public_inputs_bytes);
  ```

</TabItem>
<TabItem value="rust" label="Rust">

The Rust client library is not currently published on [crates.io](https://crates.io/); instead, you can add it as a git dependency in your `Cargo.toml` file.

- **Installation**: Add the following line to your `Cargo.toml`

  ```toml
  taceo-proof-client = { git = "https://github.com/TaceoLabs/proof-client" }
  ```

- **Setup**: Create the API client configuration

  ```rust
  let config = Configuration {
      base_path: "https://proof.taceo.network".to_string(),
      ..Default::default()
  };
  ```

- **Witness Extension + Prove Job**:

  With a full prove job, the input is secret-shared, encrypted, and distributed to the designated nodes for processing.
  The workflow does not require a precomputed extended witness; instead, the witness extension is generated during the job execution, which is then followed by proof generation.
  This approach eliminates the need to upload potentially large witnesses.

  ```rust
  let nodes = taceo_proof_client::get_random_node_providers(&config).await?;
  let blueprint_id = Uuid::parse_str("54f9ee38-0160-44e2-a1d8-08d1b6771cbf")?;
  let voucher = None; // only required for Restricted blueprints
  let abi = serde_json::from_reader::<_, Abi>(File::open("abi.json")?)?;
  let public_inputs = vec![1, 2]; // Replace with actual public input indices
  let input = File::open("Prover.toml")?;
  let job_id = taceo_proof_client::co_noir::schedule_full_job(
      &config,
      &nodes,
      blueprint_id,
      voucher,
      &abi,
      &public_inputs,
      input,
  )
  .await?;
  ```

- **Multiple Inputs Witness Extension + Prove Job**:

  This job allows multiple users to provide inputs independently, ensuring that each user's inputs remain private from the others.
  Once all required inputs have been provided, the job is dispatched to the designated nodes for execution.
  Additionally, you can optionally set a deadline to restrict how much time is allowed for all inputs to be submitted.
  Inputs can be dynamically added to an already created job. The input data is secret-shared, encrypted, and collected until the job gets scheduled.
  This approach enables more flexible workflows and computational processes.

  ```rust
  let nodes = taceo_proof_client::get_random_node_providers(&config).await?;
  let blueprint_id = Uuid::parse_str("54f9ee38-0160-44e2-a1d8-08d1b6771cbf")?;
  let voucher = None; // only required for Restricted blueprints
  let deadline = Some(Local::now() + Duration::days(1)); // Set a deadline 1 day from now
  let job_id = taceo_proof_client::co_noir::schedule_full_multiple_inputs_job(
      &config,
      &nodes,
      blueprint_id,
      voucher,
      deadline,
  )
  .await?;
  // multiple users can now add inputs to this job given the jobId and the selected nodes
  let abi = serde_json::from_reader::<_, Abi>(File::open("abi.json")?)?;
  let public_inputs = vec![1, 2]; // Replace with actual public input indices
  let input = File::open("Prover.toml")?;
  taceo_proof_client::co_noir::add_job_inputs(
      &config,
      &nodes,
      job_id,
      &abi,
      &public_inputs,
      input,
  )
  .await?;
  ```

- **Prove Job**:

  A proof job can be scheduled using either the Rep3 or Shamir Secret Sharing scheme.
  The process involves taking a witness, secret-sharing it, encrypting these shares, and distributing them to the designated nodes for execution.

  ```rust
  let nodes = taceo_proof_client::get_random_node_providers(&config).await?;
  let blueprint_id = Uuid::parse_str("54f9ee38-0160-44e2-a1d8-08d1b6771cbf")?;
  let mpc_protocol = MpcProtocol::Rep3; // specify the MPC protocol to use (Rep3 or Shamir)
  let voucher = None; // only required for Restricted blueprints
  let public_inputs = vec![1, 2]; // Replace with actual public input indices
  let witness = noir_types::witness_from_reader(File::open("witness.gz")?)?;
  let job_id = taceo_proof_client::co_noir::schedule_prove_job(
      &config,
      &nodes,
      blueprint_id,
      mpc_protocol,
      voucher,
      &public_inputs,
      witness,
  )
  .await?;
  ```

- **Fetch the job Results**:

  The results of a job execution can be retrieved via a WebSocket connection.
  Once the results are ready, the server sends a message containing the proof, public inputs, and signatures of the computing nodes.
  If any party encounters an error, an error message is returned instead.
  The received proof and public inputs are deserialized into `HonkProof<ark_bn254::Fr>` and `Vec<ark_bn254::Fr>` types as defined by [noir-types](https://github.com/TaceoLabs/co-snarks/tree/main/co-noir/noir-types).

  ```rust
  let ws_url = "wss://proof.taceo.network/api/v1/reports/subs".to_string();
  let job_id = Uuid::parse_str("9c2814d7-25d3-4de5-b61f-0a6e3bacbe99")?;
  let (proof, public_inputs, signatures) = taceo_proof_client::co_noir::fetch_job_result(
      &ws_url,
      job_id,
      StopStrategy::default(),
  ).await?;
  // serialize proof and public_inputs
  let proof_bytes = proof.to_buffer();
  let public_inputs_bytes = SerializeF::to_buffer(public_inputs, false);
  std::fs::write("proof", proof_bytes)?;
  std::fs::write("public_inputs", public_inputs_bytes)?;
  ```

</TabItem>
<TabItem value="cli" label="CLI tool">

The [proof-client](https://github.com/TaceoLabs/proof-client) repository also provides a Rust CLI tool that you can install and use to schedule coSNARK jobs.
After installing the CLI, you can run it with the `--help` flag to get more information.

```bash
Usage: taceo-proof-client co-noir <COMMAND>

Commands:
  full                  Schedule a full coNoir job including witness extension
  full-multiple-inputs  Schedule a full multiple input coNoir job including witness extension
  add-inputs            Add inputs to a coNoir job
  prove                 Schedule a prove coNoir job
  get-result            Fetch proof result
  help                  Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help
```
- **Witness Extension + Prove Job**:

  With a full prove job, the input is secret-shared, encrypted, and distributed to the designated nodes for processing.
  The workflow does not require a precomputed extended witness; instead, the witness extension is generated during the job execution, which is then followed by proof generation.
  This approach eliminates the need to upload potentially large witnesses.

  ```bash
  taceo-proof-client co-noir full \
    --blueprint a1ce14e7-628e-4dfc-be2e-8f44ccdf8b29 \
    --input Prover.toml \
    --abi abi.json \
    --public-inputs 1,2
  ```

- **Multiple Inputs Witness Extension + Prove Job**:

  This job allows multiple users to provide inputs independently, ensuring that each user's inputs remain private from the others.
  Once all required inputs have been provided, the job is dispatched to the designated nodes for execution.
  Additionally, you can optionally set a deadline to restrict how much time is allowed for all inputs to be submitted.
  Inputs can be dynamically added to an already created job. The input data is secret-shared, encrypted, and collected until the job gets scheduled.
  This approach enables more flexible workflows and computational processes.

  ```bash
  taceo-proof-client co-noir full-multiple-inputs \
    --blueprint a1ce14e7-628e-4dfc-be2e-8f44ccdf8b29
  # multiple users can now add inputs to this job given the jobId and the selected nodes
  taceo-proof-client co-noir add-inputs \
    --job 9c2814d7-25d3-4de5-b61f-0a6e3bacbe99 \
    --nodes 1,2,3 \
    --input Prover.toml \
    --abi abi.json \
    --public-inputs 1,2
  ```

- **Prove Job**:

  A proof job can be scheduled using either the Rep3 or Shamir Secret Sharing scheme.
  The process involves taking a witness, secret-sharing it, encrypting these shares, and distributing them to the designated nodes for execution.

  ```bash
  taceo-proof-client co-noir prove \
    --blueprint a1ce14e7-628e-4dfc-be2e-8f44ccdf8b29 \
    --protocol rep3 \
    --witness witness.gz \
    --public-inputs 1,2
  ```

</TabItem>
</Tabs>

After following these steps, you will have two files named `proof` and `public_inputs`, containing the **Noir Ultrahonk** proof and public inputs.

You can now use [barretenberg](https://github.com/AztecProtocol/barretenberg) to verify the proof
```bash
bb verify --scheme ultra_honk -p proof -i public_inputs -k vk --zk
```
